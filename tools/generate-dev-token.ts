#!/usr/bin/env tsx
/**
 * CLI tool to generate JWT tokens for mock users.
 *
 * This tool dynamically imports mock-users.ts to read user data and permissions,
 * generates proper JWT tokens, and writes them to mock-tokens.ts.
 *
 * Usage:
 *   npm run generate-tokens          # Generate tokens for all users
 *   npm run generate-tokens admin    # Generate token for specific user
 */

import jwt from 'jsonwebtoken';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * JWT token configuration
 */
const JWT_CONFIG = {
  issuer: 'https://localdev.com/',
  audience: ['https://core-ledger-api', 'https://localdev/userinfo'],
  scope: 'openid profile email',
  azp: 'PDPnT19ftDBAv5VLjg3OR4U6N5wqkGohT',
};

/**
 * User configuration extracted from MOCK_USERS
 */
interface UserConfig {
  role: string;
  sub: string;
  permissions: string[];
}

/**
 * Load mock users by dynamically importing the module
 */
async function loadMockUsers(): Promise<UserConfig[]> {
  const mockUsersPath = path.join(
    __dirname,
    '..',
    'src',
    'app',
    'auth',
    'mock-users.ts'
  );

  // Convert to file:// URL for dynamic import
  const fileUrl = `file://${mockUsersPath}`;

  try {
    // Dynamically import the TypeScript module (ts-node handles compilation)
    const module = await import(fileUrl);
    const MOCK_USERS = module.MOCK_USERS;

    if (!MOCK_USERS || typeof MOCK_USERS !== 'object') {
      throw new Error('MOCK_USERS export not found in mock-users.ts');
    }

    // Extract user configurations
    const configs: UserConfig[] = [];
    for (const [role, user] of Object.entries(MOCK_USERS)) {
      const mockUser = user as any;

      if (!mockUser.oidcUserData?.sub || !mockUser.permissions) {
        console.warn(`‚ö†Ô∏è  Skipping user '${role}' - missing required fields`);
        continue;
      }

      configs.push({
        role,
        sub: mockUser.oidcUserData.sub,
        permissions: mockUser.permissions,
      });
    }

    return configs;
  } catch (error) {
    console.error('‚ùå Failed to load mock-users.ts:', error);
    throw error;
  }
}

/**
 * Generate a JWT token for a user
 */
function generateToken(userConfig: UserConfig): string {
  const now = Math.floor(Date.now() / 1000);

  const payload = {
    iss: JWT_CONFIG.issuer,
    sub: userConfig.sub,
    aud: JWT_CONFIG.audience,
    iat: now,
    exp: now + 24 * 60 * 60, // 24 hours from now
    scope: JWT_CONFIG.scope,
    azp: JWT_CONFIG.azp,
    permissions: userConfig.permissions,
  };

  // Generate unsigned token (alg: none) for development use
  return jwt.sign(payload, '', { algorithm: 'none' });
}

/**
 * Generate the complete mock-tokens.ts file content
 */
function generateMockTokensFile(tokens: Record<string, string>): string {
  const header = `/**
 * Mock JWT tokens for development authentication.
 *
 * ‚ö†Ô∏è  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 *
 * This file is automatically generated by the token generator CLI tool.
 * To regenerate tokens, run: npm run generate-tokens
 *
 * Each token contains user-specific claims and permissions based on
 * the user configuration in mock-users.ts.
 *
 * Generated: ${new Date().toISOString()}
 */

export const MOCK_TOKENS: Record<string, string> = {
`;

  const tokenEntries = Object.entries(tokens)
    .map(([role, token]) => {
      const key = role.includes('-') ? `'${role}'` : role;
      return `  ${key}:\n    '${token}',`;
    })
    .join('\n');

  const footer = '\n};\n';

  return header + tokenEntries + footer;
}

/**
 * Main execution
 */
async function main(): Promise<void> {
  const args = process.argv.slice(2);
  const targetRole = args[0];

  const mockTokensPath = path.join(
    __dirname,
    '..',
    'src',
    'app',
    'auth',
    'mock-tokens.ts'
  );

  console.log('üîç Loading mock users from mock-users.ts...\n');

  // Load user configurations by importing the module
  const userConfigs = await loadMockUsers();

  if (userConfigs.length === 0) {
    console.error('‚ùå No user configurations found in mock-users.ts');
    process.exit(1);
  }

  // Filter by target role if specified
  const usersToProcess = targetRole
    ? userConfigs.filter(u => u.role === targetRole)
    : userConfigs;

  if (usersToProcess.length === 0) {
    console.error(`‚ùå Unknown role: ${targetRole}`);
    console.log(`Valid roles: ${userConfigs.map(u => u.role).join(', ')}`);
    process.exit(1);
  }

  console.log(`üìã Found ${userConfigs.length} user(s) in MOCK_USERS`);
  console.log(`üîê Generating JWT tokens for ${usersToProcess.length} user(s)...\n`);

  const tokens: Record<string, string> = {};

  // Generate tokens
  for (const config of usersToProcess) {
    const token = generateToken(config);
    tokens[config.role] = token;

    console.log(`${config.role.toUpperCase()}:`);
    console.log(`  Subject: ${config.sub}`);
    console.log(`  Permissions: ${config.permissions.length} (${config.permissions.slice(0, 3).join(', ')}...)`);
    console.log(`  Token: ${token.substring(0, 60)}...`);
    console.log('');
  }

  // If generating for a specific user, read existing tokens and merge
  let allTokens = tokens;
  if (targetRole) {
    try {
      const existingContent = fs.readFileSync(mockTokensPath, 'utf-8');
      const existingTokensMatch = existingContent.match(
        /export const MOCK_TOKENS[^{]*\{([\s\S]*?)\};/
      );
      if (existingTokensMatch) {
        const existingTokensStr = existingTokensMatch[1];
        const tokenMatches = existingTokensStr.matchAll(
          /(['"]?[\w-]+['"]?):\s*'([^']+)',?/g
        );
        for (const match of tokenMatches) {
          const role = match[1].replace(/['"]/g, '');
          const token = match[2];
          if (!tokens[role]) {
            allTokens[role] = token;
          }
        }
      }
    } catch (err) {
      // If file doesn't exist or can't be read, just use new tokens
    }
  }

  // Generate and write the complete file
  const fileContent = generateMockTokensFile(allTokens);
  fs.writeFileSync(mockTokensPath, fileContent, 'utf-8');

  console.log(`‚úÖ Updated ${mockTokensPath}`);
  console.log('\n‚ú® Done! Mock tokens have been regenerated.');
  console.log('üí° Restart your dev server to use the new tokens.\n');
}

// Run the script
main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});
